// Copyright 2018 by JCoder58.  See License.txt for license
// Auto-generated --- Do not modify.
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UE4.Core;
using UE4.CoreUObject;
using UE4.CoreUObject.Native;
using UE4.InputCore;
using UE4.Native;

#pragma warning disable CS0108
using UE4.UMG.Native;
using UE4.Engine;
using UE4.InputCore;

namespace UE4.UMG {
    ///<summary>This is a component to allow interaction with the Widget Component.</summary>
    ///<remarks>
    ///This class allows you to
    ///simulate a sort of laser pointer device, when it hovers over widgets it will send the basic signals
    ///to show as if the mouse were moving on top of it.  You'll then tell the component to simulate key presses,
    ///like Left Mouse, down and up, to simulate a mouse click.
    ///</remarks>
    public unsafe partial class WidgetInteractionComponent : SceneComponent  {

        ///<summary>Gets the last hit location on the widget in 2D, local pixel units of the render target.</summary>
        public Vector2D Get2DHitLocation()  => 
            WidgetInteractionComponent_methods.Get2DHitLocation_method.Invoke(ObjPointer);

        ///<summary>Get the currently hovered widget component.</summary>
        public WidgetComponent GetHoveredWidgetComponent()  => 
            WidgetInteractionComponent_methods.GetHoveredWidgetComponent_method.Invoke(ObjPointer);

        ///<summary>Gets the last hit result generated by the component.  Returns the custom hit result if that was set.</summary>
        public void GetLastHitResult(HitResult ReturnValue)  => 
            WidgetInteractionComponent_methods.GetLastHitResult_method.Invoke(ObjPointer, ReturnValue);

        ///<summary>Returns true if a widget under the hit result is focusable.</summary>
        ///<remarks>
        ///e.g. Slate widgets that
        ///return true for SupportsKeyboardFocus().
        ///</remarks>
        public bool IsOverFocusableWidget()  => 
            WidgetInteractionComponent_methods.IsOverFocusableWidget_method.Invoke(ObjPointer);

        ///<summary>
        ///Returns true if a widget under the hit result is has a visibility that makes it hit test
        ///visible.
        ///</summary>
        ///<remarks>e.g. Slate widgets that return true for GetVisibility().IsHitTestVisible().</remarks>
        public bool IsOverHitTestVisibleWidget()  => 
            WidgetInteractionComponent_methods.IsOverHitTestVisibleWidget_method.Invoke(ObjPointer);

        ///<summary>Returns true if a widget under the hit result is interactive.</summary>
        ///<remarks>
        ///e.g. Slate widgets
        ///that return true for IsInteractable().
        ///</remarks>
        public bool IsOverInteractableWidget()  => 
            WidgetInteractionComponent_methods.IsOverInteractableWidget_method.Invoke(ObjPointer);

        ///<summary>Does both the press and release of a simulated keyboard key.</summary>
        public bool PressAndReleaseKey(Key Key)  => 
            WidgetInteractionComponent_methods.PressAndReleaseKey_method.Invoke(ObjPointer, Key);

        ///<summary>Press a key as if it had come from the keyboard.</summary>
        ///<remarks>
        ///Avoid using this for 'a-z|A-Z', things like
        ///the Editable Textbox in Slate expect OnKeyChar to be called to signal a specific character being
        ///send to the widget.  So for those cases you should use SendKeyChar.
        ///</remarks>
        public bool PressKey(Key Key, bool bRepeat)  => 
            WidgetInteractionComponent_methods.PressKey_method.Invoke(ObjPointer, Key, bRepeat);

        ///<summary>Presses a key as if the mouse/pointer were the source of it.</summary>
        ///<remarks>
        ///Normally you would just use
        ///Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
        ///send other keys to signal widgets to take special actions if they're under the cursor.
        ///</remarks>
        public void PressPointerKey(Key Key)  => 
            WidgetInteractionComponent_methods.PressPointerKey_method.Invoke(ObjPointer, Key);

        ///<summary>Releases a key as if it had been released by the keyboard.</summary>
        public bool ReleaseKey(Key Key)  => 
            WidgetInteractionComponent_methods.ReleaseKey_method.Invoke(ObjPointer, Key);

        ///<summary>Releases a key as if the mouse/pointer were the source of it.</summary>
        ///<remarks>
        ///Normally you would just use
        ///Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
        ///send other keys to signal widgets to take special actions if they're under the cursor.
        ///</remarks>
        public void ReleasePointerKey(Key Key)  => 
            WidgetInteractionComponent_methods.ReleasePointerKey_method.Invoke(ObjPointer, Key);

        ///<summary>Sends a scroll wheel event to the widget under the last hit result.</summary>
        public void ScrollWheel(float ScrollDelta)  => 
            WidgetInteractionComponent_methods.ScrollWheel_method.Invoke(ObjPointer, ScrollDelta);

        ///<summary>
        ///Transmits a list of characters to a widget by simulating a OnKeyChar event for each key listed in
        ///the string.
        ///</summary>
        public bool SendKeyChar(string Characters, bool bRepeat)  => 
            WidgetInteractionComponent_methods.SendKeyChar_method.Invoke(ObjPointer, Characters, bRepeat);

        ///<summary>Set custom hit result.  This is only taken into account if InteractionSource is set to EWidgetInteractionSource::Custom.</summary>
        public void SetCustomHitResult(HitResult HitResult)  => 
            WidgetInteractionComponent_methods.SetCustomHitResult_method.Invoke(ObjPointer, HitResult);
         //TODO: multicast delegate FOnHoveredWidgetChanged OnHoveredWidgetChanged
        ///<summary>Represents the Virtual User Index.</summary>
        ///<remarks>
        ///Each virtual user should be represented by a different
        ///index number, this will maintain separate capture and focus states for them.  Each
        ///controller or finger-tip should get a unique PointerIndex.
        ///</remarks>
        public unsafe int VirtualUserIndex {
            get {return WidgetInteractionComponent_ptr->VirtualUserIndex;}
            set {WidgetInteractionComponent_ptr->VirtualUserIndex = value;}
        }
        ///<summary>Each user virtual controller or virtual finger tips being simulated should use a different pointer index.</summary>
        public unsafe float PointerIndex {
            get {return WidgetInteractionComponent_ptr->PointerIndex;}
            set {WidgetInteractionComponent_ptr->PointerIndex = value;}
        }
        ///<summary>The trace channel to use when tracing for widget components in the world.</summary>
        public unsafe byte TraceChannel {
            get {return WidgetInteractionComponent_ptr->TraceChannel;}
            set {WidgetInteractionComponent_ptr->TraceChannel = value;}
        }
        ///<summary>The distance in game units the component should be able to interact with a widget component.</summary>
        public unsafe float InteractionDistance {
            get {return WidgetInteractionComponent_ptr->InteractionDistance;}
            set {WidgetInteractionComponent_ptr->InteractionDistance = value;}
        }
         //TODO: enum EWidgetInteractionSource InteractionSource
        public bool bEnableHitTesting {
            get {return Main.GetGetBoolPropertyByName(this, "bEnableHitTesting"); }
            set {Main.SetGetBoolPropertyByName(this, "bEnableHitTesting", value); }
        }
        public bool bShowDebug {
            get {return Main.GetGetBoolPropertyByName(this, "bShowDebug"); }
            set {Main.SetGetBoolPropertyByName(this, "bShowDebug", value); }
        }
        ///<summary>Determines the color of the debug lines.</summary>
        public unsafe LinearColor DebugColor {
            get {return WidgetInteractionComponent_ptr->DebugColor;}
            set {WidgetInteractionComponent_ptr->DebugColor = value;}
        }
        ///<summary>Stores the custom hit result set by the player.</summary>
        public unsafe HitResult CustomHitResult {
            get {return WidgetInteractionComponent_ptr->CustomHitResult;}
            set {WidgetInteractionComponent_ptr->CustomHitResult = value;}
        }
        ///<summary>The 2D location on the widget component that was hit.</summary>
        public unsafe Vector2D LocalHitLocation {
            get {return WidgetInteractionComponent_ptr->LocalHitLocation;}
            set {WidgetInteractionComponent_ptr->LocalHitLocation = value;}
        }
        ///<summary>The last 2D location on the widget component that was hit.</summary>
        public unsafe Vector2D LastLocalHitLocation {
            get {return WidgetInteractionComponent_ptr->LastLocalHitLocation;}
            set {WidgetInteractionComponent_ptr->LastLocalHitLocation = value;}
        }
        ///<summary>The widget component we're currently hovering over.</summary>
        public unsafe WidgetComponent HoveredWidgetComponent {
            get {return WidgetInteractionComponent_ptr->HoveredWidgetComponent;}
            set {WidgetInteractionComponent_ptr->HoveredWidgetComponent = value;}
        }
        ///<summary>The last hit result we used.</summary>
        public unsafe HitResult LastHitResult {
            get {return WidgetInteractionComponent_ptr->LastHitResult;}
            set {WidgetInteractionComponent_ptr->LastHitResult = value;}
        }
        public bool bIsHoveredWidgetInteractable {
            get {return Main.GetGetBoolPropertyByName(this, "bIsHoveredWidgetInteractable"); }
            set {Main.SetGetBoolPropertyByName(this, "bIsHoveredWidgetInteractable", value); }
        }
        public bool bIsHoveredWidgetFocusable {
            get {return Main.GetGetBoolPropertyByName(this, "bIsHoveredWidgetFocusable"); }
            set {Main.SetGetBoolPropertyByName(this, "bIsHoveredWidgetFocusable", value); }
        }
        public bool bIsHoveredWidgetHitTestVisible {
            get {return Main.GetGetBoolPropertyByName(this, "bIsHoveredWidgetHitTestVisible"); }
            set {Main.SetGetBoolPropertyByName(this, "bIsHoveredWidgetHitTestVisible", value); }
        }
        ///<summary>The arrow component we show at editor time.</summary>
        public unsafe ArrowComponent ArrowComponent {
            get {return WidgetInteractionComponent_ptr->ArrowComponent;}
            set {WidgetInteractionComponent_ptr->ArrowComponent = value;}
        }
        static WidgetInteractionComponent() {
            StaticClass = Main.GetClass("WidgetInteractionComponent");
        }
        internal unsafe WidgetInteractionComponent_fields* WidgetInteractionComponent_ptr => (WidgetInteractionComponent_fields*) ObjPointer.ToPointer();

        ///<summary>Convert from IntPtr to UObject</summary>
        public static implicit operator WidgetInteractionComponent(IntPtr p) => UObject.Make<WidgetInteractionComponent>(p);
        ///<summary>Get UE4 Class</summary>
        public static Class StaticClass {get; private set;}
        ///<summary>Get UE4 Default Object for this Class</summary>
        public static WidgetInteractionComponent DefaultObject => Main.GetDefaultObject(StaticClass);
        ///<summary>Spawn an object of this class</summary>
        public static WidgetInteractionComponent New(UObject obj = null, Name name = new Name()) => Main.NewObject(StaticClass, obj, name);
    }
}
